{
    "collab_server" : "",
    "contents" : "#' @importFrom utils head tail \n#' @importFrom plyr ddply\n#' @importFrom nleqslv nleqslv\n#' @importFrom methods setClass setMethod\n#' @importFrom stats uniroot stepfun var sd quantile\n\n\n##############################################################################\n# Augmented Estimating Equations (AEE)\n##############################################################################\ndoPanelFit.AEE <- function(DF, panelMatrix, timeGrid, X, engine, stdErr, weight=NULL) {\n  \n  N <- nrow(panelMatrix)\n  K <- ncol(panelMatrix)\n  \n  eStep <- function(lambda) {\n    e <- matrix(0, N, K)\n    \n    for (i in 1:N) {\n      end <- which(!is.na(panelMatrix[i, ]))\n      start <- c(1, head(end, -1) + 1)\n      \n      for (j in which(panelMatrix[i, end] > 0)) {\n        sq <- seq(start[j], end[j])\n        e[i, sq] <- panelMatrix[i, end[j]] * lambda[sq] / sum(lambda[sq])\n      }\n    }\n    e\n  }\n  \n  \n  if (is.null(weight)) {\n  f <- function(beta, e) {\n    lambda <- c(colSums(e)) / c(t(r) %*% exp(X %*% beta))\n    c(t(X) %*% (rowSums(e) - c(exp(X %*% beta)) * c(r %*% lambda)))\n  }\n  \n  sStep <- function(f, beta, e) {\n    if (ncol(X) == 1) {\n      beta <- uniroot(f, engine@interval, e=e)$root\n    } else {\n      beta <- nleqslv(beta, function(x) f(x, e))$x\n    }\n    \n    lambda <- colSums(e) / c(t(r) %*% exp(X %*% beta))\n    list(beta=beta,\n         lambda=lambda)\n  }\n  \n  ##############################\n  # Initialize e and r matrix\n  e <- r <- matrix(0, N, K)\n  for (i in 1:N) {\n    set <- which(!is.na(panelMatrix[i, ]))\n    mi <- tail(set, 1)\n    dset <- diff(c(0, set))\n    \n    e[i, 1:mi] <- rep(panelMatrix[i, set] / dset, dset)\n    r[i, 1:mi] <- 1\n  }\n  \n  convergence <- 1\n  sRes <- sStep(f, engine@betaInit, e)\n  for (i in 2:engine@maxIter) {\n    e <- eStep(sRes$lambda)\n    \n    betaPre <- sRes$beta\n    sRes <- sStep(f, sRes$beta, e)\n    s <- sRes$beta - betaPre\n    \n    if (max(abs(s)) < engine@absTol | max(abs(s / betaPre)) < engine@relTol) {\n      convergence <- 0\n      break\n    }\n  }\n  iter <- i\n  }\n  \n  \n  if (!is.null(weight)) {\n    f <- function(beta, e, weight) {\n      lambda <- c(colSums(e)) / c(t(r) %*% exp(X %*% beta))\n      c(t(X) %*% diag(weight) %*% (rowSums(e) - c(exp(X %*% beta)) * c(r %*% lambda)))\n    }\n    \n    sStep <- function(f, beta, e, weight) {\n      if (ncol(X) == 1) {\n        beta <- uniroot(f, engine@interval, e=e, weight=weight)$root\n      } else {\n        beta <- nleqslv(beta, function(x) f(x, e, weight))$x\n      }\n      \n      lambda <- colSums(e) / c(t(r) %*% exp(X %*% beta))\n      list(beta=beta,\n           lambda=lambda)\n    }\n    \n    ##############################\n    # Initialize e and r matrix\n    e <- r <- matrix(0, N, K)\n    for (i in 1:N) {\n      set <- which(!is.na(panelMatrix[i, ]))\n      mi <- tail(set, 1)\n      dset <- diff(c(0, set))\n      \n      e[i, 1:mi] <- rep(panelMatrix[i, set] / dset, dset)\n      r[i, 1:mi] <- 1\n    }\n    \n    convergence <- 1\n    sRes <- sStep(f, engine@betaInit, e, weight)\n    \n    for (i in 2:engine@maxIter) {\n      #e <- eStep(sRes$lambda)\n      e <- eStep(sRes$lambda)\n      \n      betaPre <- sRes$beta\n      sRes <- sStep(f, sRes$beta, e, weight)\n      s <- sRes$beta - betaPre\n      \n      if (max(abs(s)) < engine@absTol | max(abs(s / betaPre)) < engine@relTol) {\n        convergence <- 'Converged'\n        break\n      }\n    }\n    iter <- i\n  }  \n  \n  list(beta=sRes$beta,\n       baseline=stepfun(timeGrid, cumsum(c(0, sRes$lambda))),\n       timeGrid=timeGrid,\n       lambda=sRes$lambda,\n       convergence=convergence,\n       iter=iter)\n}\n\n\n\n##############################################################################\n# Extension of Augmented Estimating Equations (AEEX)\n##############################################################################\ndoPanelFit.AEEX <- function(DF, panelMatrix, timeGrid, X, engine, stdErr, weight=NULL) {\n  N <- nrow(panelMatrix)\n  K <- ncol(panelMatrix)\n  \n  eStep <- function(lambda, a) {\n    e <- matrix(0, N, K)\n    \n    for (i in 1:N) {\n      end <- which(!is.na(panelMatrix[i, ]))\n      start <- c(1, head(end, -1) + 1)\n      \n      for (j in which(panelMatrix[i, end] > 0)) {\n        sq <- seq(start[j], end[j])\n        e[i, sq] <- panelMatrix[i, end[j]] * lambda[sq] / sum(lambda[sq])\n      }\n      \n      if (tail(end, 1) < K) {\n        sq <- seq(tail(end, 1) + 1, K)\n        e[i, sq] <- (sum(panelMatrix[i, end]) + a) * lambda[sq] /\n          (sum(lambda[-sq]) + a)\n      }\n    }\n    e\n  }\n  \n  if (is.null(weight)) {\n  f <- function(beta, e) {\n    lambda <- c(colSums(e)) / sum(exp(X %*% beta))\n    c(t(X) %*% (rowSums(e) - c(exp(X %*% beta)) * sum(lambda)))\n  }\n  \n  sStep <- function(f, beta, e) {\n    if (ncol(X) == 1) {\n      beta <- uniroot(f, engine@interval, e=e)$root\n    } else {\n      beta <- nleqslv(beta, function(x) f(x, e))$x\n    }\n    \n    lambda <- colSums(e) / sum(exp(X %*% beta))\n    list(beta=beta,\n         lambda=lambda)\n  }\n  \n  ##############################\n  # Initialize e matrix\n  e <- matrix(0, N, K)\n  for (i in 1:N) {\n    sq <- which(!is.na(panelMatrix[i, ]))\n    mi <- tail(sq, 1)\n    dsq <- diff(c(0, sq))\n    \n    e[i, 1:mi] <- rep(panelMatrix[i, sq] / dsq, dsq)\n    \n    if (mi < K) {\n      e[i, (mi + 1):K] <- sum(panelMatrix[i, sq]) / mi\n    }\n  }\n  \n  a <- engine@a\n  \n  # Iteration\n  convergence <- 1\n  sRes <- sStep(f, engine@betaInit, e)\n  for (i in 2:engine@maxIter) {\n    e <- eStep(sRes$lambda, a)\n    \n    betaPre <- sRes$beta\n    sRes <- sStep(f, sRes$beta, e)\n    s <- sRes$beta - betaPre\n    \n    if (max(abs(s)) < engine@absTol | max(abs(s / betaPre)) < engine@relTol) {\n      convergence <- 0\n      break\n    }\n  }\n  iter <- i\n  }\n  \n  if (!is.null(weight)) {\n    f <- function(beta, e, weight) {\n      lambda <- c(colSums(e)) / sum(exp(X %*% beta))\n      c(t(X) %*% diag(weight) %*% (rowSums(e) - c(exp(X %*% beta)) * sum(lambda)))\n    }\n    \n    sStep <- function(f, beta, e, weight) {\n      if (ncol(X) == 1) {\n        beta <- uniroot(f, engine@interval, e=e, weight=weight)$root\n      } else {\n        beta <- nleqslv(beta, function(x) f(x, e, weight))$x\n      }\n      \n      lambda <- colSums(e) / sum(exp(X %*% beta))\n      list(beta=beta,\n           lambda=lambda)\n    }\n    \n    ##############################\n    # Initialize e matrix\n    e <- matrix(0, N, K)\n    for (i in 1:N) {\n      sq <- which(!is.na(panelMatrix[i, ]))\n      mi <- tail(sq, 1)\n      dsq <- diff(c(0, sq))\n      \n      e[i, 1:mi] <- rep(panelMatrix[i, sq] / dsq, dsq)\n      \n      if (mi < K) {\n        e[i, (mi + 1):K] <- sum(panelMatrix[i, sq]) / mi\n      }\n    }\n    \n    a <- engine@a\n    \n    # Iteration\n    convergence <- 1\n    sRes <- sStep(f, engine@betaInit, e, weight)\n    for (i in 2:engine@maxIter) {\n      #e <- estepAEE(panelMatrix,sRes$lambda,a)\n      e <- eStep(sRes$lambda,a)\n      \n      betaPre <- sRes$beta\n      sRes <- sStep(f, sRes$beta, e, weight)\n      s <- sRes$beta - betaPre\n      \n      if (max(abs(s)) < engine@absTol | max(abs(s / betaPre)) < engine@relTol) {\n        convergence <- 'Converged'\n        break\n      }\n    }\n    iter <- i\n  }\n  \n  list(beta=sRes$beta,\n       baseline=stepfun(timeGrid, cumsum(c(0, sRes$lambda))),\n       timeGrid=timeGrid,\n       lambda=sRes$lambda,\n       convergence=convergence,\n       iter=iter)\n}\n\n\n\n\n##############################################################################\n# Bootstrap variance estimation for AEE\n##############################################################################\ndoPanelFit.AEE.Bootstrap <- function(DF, panelMatrix, timeGrid, X, engine, stdErr, weight, boot) {\n  N <- nrow(panelMatrix)\n  K <- ncol(panelMatrix)\n  tau <- max(timeGrid)\n  \n  res <- doPanelFit.AEE(DF, panelMatrix, timeGrid, X, engine, weight)\n  engine@betaInit <- res$beta\n  \n  R <- boot\n  betaMatrix <- matrix(0, R, length(res$beta))\n  baselineMatrix <- matrix(NA, R, K)\n  convergence <- rep(0, R)\n  \n  uID <- unique(DF$ID)\n  \n  for (i in 1:R) {\n    index <- sort(sample(1:N, size=N, replace=TRUE))\n    \n    mylist <- apply(matrix(index), 1, function(x) which(DF$ID == uID[x]))\n    DF2 <- DF[unlist(mylist), ]\n    DF2$ID <- rep(1:N, unlist(lapply(mylist, length)))\n    \n    panelMatrix2 <- panelMatrix[index, ]\n    X2 <- as.matrix(X[index, ])\n    subCol <- which(colSums(!is.na(panelMatrix2)) > 0)\n    panelMatrix2 <- panelMatrix2[, subCol]\n    timeGrid2 <- timeGrid[subCol]\n    \n    res2 <- doPanelFit.AEE(DF2, panelMatrix2, timeGrid2, X2, engine, weight)\n    betaMatrix[i, ] <- res2$beta\n    \n    tau2 <- max(timeGrid2)\n    sq <- which(timeGrid <= tau2)\n    if (tau2 < tau)\n      baselineMatrix[i, sq] <- res2$baseline(timeGrid[sq])\n    else\n      baselineMatrix[i, ] <- res2$baseline(timeGrid)\n    \n    convergence[i] <- res2$convergence\n  }\n  \n  converged <- which(convergence == 0)\n  betaVar <- var(betaMatrix[converged, ], na.rm=TRUE)\n  betaSE <- sqrt(diag(as.matrix(betaVar)))\n  baselineSE <- sd(baselineMatrix[converged, ], na.rm=TRUE)\n  \n  # 2.5% and 97.5% quantiles of baseline bootstrap estimates, 2*K\n  baselineQT <- apply(baselineMatrix[converged, ], 2, quantile,\n                      probs=c(0.025, 0.975), na.rm=TRUE, names=FALSE)\n  \n  c(res, list(betaSE=betaSE, betaVar=betaVar,\n              baselineSE=baselineSE, baselineQT=baselineQT, R=length(converged)))\n}\n\n\n\n\n\n\n##############################################################################\n# Bootstrap variance estimation for AEEX\n##############################################################################\ndoPanelFit.AEEX.Bootstrap <- function(DF, panelMatrix, timeGrid, X, engine, stdErr, weight, boot) {\n  N <- nrow(panelMatrix)\n  K <- ncol(panelMatrix)\n  tau <- max(timeGrid)\n  \n  if (is.null(weight)) {\n    weight <- rep(1,nrow(X))\n  } \n  \n  res <- doPanelFit.AEEX(DF, panelMatrix, timeGrid, X, engine, weight)\n  engine@betaInit <- res$beta\n  \n  R <- boot\n  betaMatrix <- matrix(0, R, length(res$beta))\n  baselineMatrix <- matrix(NA, R, K)\n  convergence <- rep(0, R)\n  \n  uID <- unique(DF$ID)\n  \n  for (i in 1:R) {\n    index <- sort(sample(1:N, size=N, replace=TRUE))\n    \n    mylist <- apply(matrix(index), 1, function(x) which(DF$ID == uID[x]))\n    DF2 <- DF[unlist(mylist), ]\n    DF2$ID <- rep(1:N, unlist(lapply(mylist, length)))\n    \n    panelMatrix2 <- panelMatrix[index, ]\n    X2 <- as.matrix(X[index, ])\n    subCol <- which(colSums(!is.na(panelMatrix2)) > 0)\n    panelMatrix2 <- panelMatrix2[, subCol]\n    timeGrid2 <- timeGrid[subCol]\n    \n    res2 <- doPanelFit.AEEX(DF2, panelMatrix2, timeGrid2, X2, engine, weight)\n    betaMatrix[i, ] <- res2$beta\n    \n    tau2 <- max(timeGrid2)\n    sq <- which(timeGrid <= tau2)\n    if (tau2 < tau)\n      baselineMatrix[i, sq] <- res2$baseline(timeGrid[sq])\n    else\n      baselineMatrix[i, ] <- res2$baseline(timeGrid)\n    \n    convergence[i] <- res2$convergence\n  }\n  \n  converged <- which(convergence == 0)\n  betaVar <- var(betaMatrix[converged, ], na.rm=TRUE)\n  betaSE <- sqrt(diag(as.matrix(betaVar)))\n  baselineSE <- sd(baselineMatrix[converged, ], na.rm=TRUE)\n  \n  # 2.5% and 97.5% quantiles of baseline bootstrap estimates, 2*K\n  baselineQT <- apply(baselineMatrix[converged, ], 2, quantile,\n                      probs=c(0.025, 0.975), na.rm=TRUE, names=FALSE)\n  \n  c(res, list(betaSE=betaSE, betaVar=betaVar,\n              baselineSE=baselineSE, baselineQT=baselineQT, R=length(converged)))\n}\n\n\n\n##############################################################################\n# Observed information matrix based variance estimation for AEE\n##############################################################################\ndoPanelFit.AEE.Sandwich <- function(DF, panelMatrix, timeGrid, X, engine, stdErr, weight=NULL) {\n  N <- nrow(panelMatrix)\n  K <- ncol(panelMatrix)\n  \n  res <- doPanelFit.AEE(DF, panelMatrix, timeGrid, X, engine, NULL)\n  beta <- res$beta\n  lambda <- res$lambda\n  \n  atRiskMatrix <- matrix(0, N, K)\n  lastObs <- apply(panelMatrix, 1, function(x) tail(which(!is.na(x)), 1))\n  atRiskMatrix[col(atRiskMatrix) <= lastObs] <- 1\n  \n  # A is the complete information matrix for all subjects\n  A11 <- diag(c(t(exp(X %*% beta)) %*% atRiskMatrix))\n  A21 <- t(c(exp(X %*% beta)) * X) %*% atRiskMatrix\n  A22 <- t(X) %*% (X * c(exp(X %*% beta)) * c(atRiskMatrix %*% lambda))\n  A <- rbind(cbind(A11, t(A21) * lambda),\n             cbind(A21, A22))\n  \n  # B is the missing information matrix for all subjects\n  B <- matrix(0, K + ncol(X), K + ncol(X))\n  for (i in 1:N) {\n    sq <- which(!is.na(panelMatrix[i, ]))\n    mi <- panelMatrix[i, sq]\n    \n    if (is.na(panelMatrix[i, K])) {\n      sq <- c(sq, K)\n      mi <- c(mi, 0)\n    }\n    \n    dsq <- diff(c(0, sq))\n    ndsq <- length(dsq)\n    \n    # normalize lambda, multinomial\n    p <- lambda / rep(diff(c(0, cumsum(lambda)[sq])), dsq)\n    p[which(p == Inf)] <- 1\n    blkp <- p * diag(1, ndsq)[rep(1:ndsq, dsq), ]\n    \n    # atRisk (rij) is taken care of\n    Xi <- X[i, ]\n    B11 <- rep(mi, dsq) * (diag(p) - blkp %*% t(blkp))\n    B12 <- rowSums(B11) %*% t(Xi)\n    B22 <- sum(B11) * Xi %*% t(Xi)\n    B <- B + rbind(cbind(B11, B12),\n                   cbind(t(B12), B22))\n    # matrix.plot(B)\n  }\n  \n  # Inverse of observed information matrix\n  V <- solve(A - B)\n  \n  # Regularization\n  dgV <- diag(V)\n  dgV[which(dgV < 0)] <- 0\n  diag(V) <- dgV\n  \n  # Sandwich estimator\n  e <- matrix(0, N, K)\n  for (i in 1:N) {\n    end <- which(!is.na(panelMatrix[i, ]))\n    start <- c(1, head(end, -1) + 1)\n    \n    for (j in which(panelMatrix[i, end] > 0)) {\n      sq <- seq(start[j], end[j])\n      e[i, sq] <- panelMatrix[i, end[j]] * lambda[sq] / sum(lambda[sq])\n    }\n  }\n  U1 <- (t(e) - outer(lambda, c(exp(X %*% beta)))) * t(atRiskMatrix)\n  U2 <- t(colSums(U1) * X)\n  U <- rbind(U1, U2)\n  V <- V %*% (U %*% t(U)) %*% t(V)\n  \n  ##\n  betaVar <- V[-c(1:K), -c(1:K)]\n  betaSE <- sqrt(diag(as.matrix(betaVar)))\n  \n  lowOne <- matrix(0, K, K)\n  lowOne[row(lowOne) >= col(lowOne)] <- 1\n  vLambda <- diag(lowOne %*% V[1:K, 1:K] %*% t(lowOne))\n  baselineSE <- sqrt(vLambda)\n  \n  c(res, list(betaSE=betaSE, betaVar=betaVar, baselineSE=baselineSE))\n}\n\n\n##############################################################################\n# Observed information matrix based variance estimation for AEEX\n##############################################################################\ndoPanelFit.AEEX.Sandwich <- function(DF, panelMatrix, timeGrid, X, engine, stdErr, weight=NULL) {\n  N <- nrow(panelMatrix)\n  K <- ncol(panelMatrix)\n  \n  res <- doPanelFit.AEEX(DF, panelMatrix, timeGrid, X, engine, NULL)\n  beta <- res$beta\n  lambda <- res$lambda\n  \n  atRiskMatrix <- matrix(1, N, K)\n  \n  # A is the complete information matrix for all subjects\n  A11 <- diag(c(t(exp(X %*% beta)) %*% atRiskMatrix))\n  A21 <- t(c(exp(X %*% beta)) * X) %*% atRiskMatrix\n  A22 <- t(X) %*% (X * c(exp(X %*% beta)) * c(atRiskMatrix %*% lambda))\n  A <- rbind(cbind(A11, t(A21) * lambda),\n             cbind(A21, A22))\n  \n  # B is the missing information matrix for all subjects\n  B <- matrix(0, K + ncol(X), K + ncol(X))\n  for (i in 1:N) {\n    sq <- which(!is.na(panelMatrix[i, ]))\n    mi <- panelMatrix[i, sq]\n    \n    if (is.na(panelMatrix[i, K])) {\n      y1 <- sum(mi)\n      mu1 <- sum(lambda[seq(1, tail(mi, 1))])\n      mu2 <- sum(lambda[seq(tail(mi, 1) + 1, K)])\n      \n      sq <- c(sq, K)\n      mi <- c(mi, (y1 + engine@a) * mu2 / (mu1 + engine@a))\n    }\n    \n    dsq <- diff(c(0, sq))\n    ndsq <- length(dsq)\n    \n    # normalize lambda, multinomial\n    p <- lambda / rep(diff(c(0, cumsum(lambda)[sq])), dsq)\n    p[which(p == Inf)] <- 1\n    blkp <- p * diag(1, ndsq)[rep(1:ndsq, dsq), ]\n    \n    Xi <- X[i, ]\n    B11 <- rep(mi, dsq) * (diag(p) - blkp %*% t(blkp))\n    \n    if (is.na(panelMatrix[i, K])) {\n      p[seq(1, K - tail(dsq, 1))] <- 0\n      B11 <- B11 + outer(p, p) * (y1 + engine@a) *\n        mu2 / (mu2 + engine@a) * (1 + mu1 / (mu2 + engine@a))\n    }\n    \n    B12 <- rowSums(B11) %*% t(Xi)\n    B22 <- sum(B11) * Xi %*% t(Xi)\n    B <- B + rbind(cbind(B11, B12),\n                   cbind(t(B12), B22))\n    # matrix.plot(B)\n  }\n  \n  # Inverse of observed information matrix\n  V <- solve(A - B)\n  \n  # Regularization\n  dgV <- diag(V)\n  dgV[which(dgV < 0)] <- 0\n  diag(V) <- dgV\n  \n  # Sandwich estimator\n  e <- matrix(0, N, K)\n  for (i in 1:N) {\n    end <- which(!is.na(panelMatrix[i, ]))\n    start <- c(1, head(end, -1) + 1)\n    \n    for (j in which(panelMatrix[i, end] > 0)) {\n      sq <- seq(start[j], end[j])\n      e[i, sq] <- panelMatrix[i, end[j]] * lambda[sq] / sum(lambda[sq])\n    }\n  }\n  U1 <- (t(e) - outer(lambda, c(exp(X %*% beta)))) * t(atRiskMatrix)\n  U2 <- t(colSums(U1) * X)\n  U <- rbind(U1, U2)\n  V <- V %*% (U %*% t(U)) %*% t(V)\n  \n  ##\n  betaVar <- V[-c(1:K), -c(1:K)]\n  betaSE <- sqrt(diag(as.matrix(betaVar)))\n  \n  lowOne <- matrix(0, K, K)\n  lowOne[row(lowOne) >= col(lowOne)] <- 1\n  vLambda <- diag(lowOne %*% V[1:K, 1:K] %*% t(lowOne))\n  baselineSE <- sqrt(vLambda)\n  \n  c(res, list(betaSE=betaSE, betaVar=betaVar, baselineSE=baselineSE))\n}\n\n\n\n\n\ndataCollapse <- function (dataset, TS, by, col, func = sum, ...) \n{\n  \n  #dataset=data; TS = \"TimeStamp\"; col = \"counts\"; by = 60\n  ts = as.vector(dataset[, TS])\n  ct = as.numeric(dataset[, col])\n  timeRange = range(as.vector(ts))\n  epoch = as.numeric(as.POSIXlt(ts[2],origin=\"1970-01-01\") - as.POSIXlt(ts[1],origin=\"1970-01-01\"))\n  ratio = by/epoch\n  newrange = c(0:(ceiling(length(ts)/ratio) - 1)) * by\n  step1 = rep(as.POSIXlt(timeRange[1], tz = \"GMT\",origin=\"1970-01-01\"), length(newrange))\n  newts = gsub(\" GMT\", \"\", step1 + newrange)\n  newct = rep(NA, length(newrange))\n  i = 1\n  prevts = while (i <= length(newts)) {\n    start = (i - 1) * ratio + 1\n    end = i * ratio\n    if (end > length(ct)) {\n      end = length(ct)\n    }\n    newct[i] = func(ct[start:end], ...)\n    i = i + 1\n  }\n  tf = data.frame(timestamp = newts, counts = newct)\n  names(tf) = c(TS, col)\n  return(tf)\n}\n##############################################################################\n# Class Definition\n##############################################################################\nsetClass(\"Engine\",\n         representation(betaInit=\"numeric\", interval=\"numeric\",\n                        maxIter=\"numeric\", absTol=\"numeric\", relTol=\"numeric\"),\n         prototype(betaInit=0, interval=c(-5, 5),\n                   maxIter=150, absTol=1e-6, relTol=1e-6),\n         contains=\"VIRTUAL\")\n\nsetClass(\"AEE\",\n         representation(),\n         prototype(),\n         contains=\"Engine\")\n\nsetClass(\"AEEX\",\n         representation(a=\"numeric\"),\n         prototype(maxIter=500, a=0.1),\n         contains=\"Engine\")\n\n#setClass(\"AEEX\",\n#         representation(a=\"numeric\"),\n#         prototype(a=0.1),\n#         contains=\"Engine\")\n\n\nsetClass(\"StdErr\")\n\nsetClass(\"Sandwich\",\n         representation(),\n         prototype(),\n         contains=\"StdErr\")\n\nsetClass(\"Bootstrap\",\n         representation(R=\"numeric\"),\n         prototype(R=30),\n         contains=\"StdErr\")\n\n",
    "created" : 1512343806747.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2478459854",
    "id" : "BF641539",
    "lastKnownWriteTime" : 1512343676,
    "last_content_update" : 1512343676,
    "path" : "Z:/My documents/1packages/acc/R/internal.R",
    "project_path" : "R/internal.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}